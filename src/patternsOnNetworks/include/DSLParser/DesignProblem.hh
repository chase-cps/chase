/**
 * @author      <a href="mailto:michele.lora@univr.it">Michele Lora</a>
 * @date        11/12/2019
 *              This project is released under the 3-Clause BSD License.
 *
 */

#pragma once
#include "DSLParser/ProblemDefinitions.hh"
#include "utilities/Factory.hh"
#include "Chase.hh"

#include <bitset>




namespace patternsOnNetworks {



    /// @brief The main class to represent the design problem built by parsing
    /// the specification file.
    class DesignProblem {
    public:

        /// @brief Set of the domain specific types used in the design domain.
        /// It is implemented as a map having the name of they type as key
        /// to ease the search of a type.
        std::map< std::string, DomainSpecificType * > domain_specific_types;

        /// @brief List of components groups. Implemented as a map to ease the
        /// serach of the group. The key is the name.
        std::map< std::string, ComponentsGroup * > components_groups;

        /// @brief List of components. Implemented as a map to ease its search.
        /// The key of the map is the component name.
        std::map< std::string, Component * > components;

        /// @brief Map of abbreviations and names.
        /// The key of the map is the abbreviation.
        std::map< std::string, std::string > abbreviations;

        /// @brief List of the switched connections in the system architecture.
        std::set< SwitchedConnection * > switched_connections;

        /// @brief List of the unswitched connections
        /// in the system architecture.
        std::set< Connection * > unswitched_connections;

        /// @brief The set of Assumptions.
        std::set< SpecFunction * > assumptions;

        /// @brief The set of Requirements.
        std::set< SpecFunction * > requirements;

        /// @brief Constructor.
        DesignProblem();

        /// @brief Destructor.
        ~DesignProblem();

        /// @brief Function returning the contract.
        /// @return The contract.
        chase::Contract * getContract();

    protected:

        /// @brief The contract to be generated by the parser.
        chase::Contract * _contract;

        /// @brief Map containing the state variables of the components.
        std::map< std::string, std::shared_ptr< chase::Variable > > _stateVariables;

        /// @brief Map containing the intention variables of the components.
        std::map< std::string, std::shared_ptr< chase::Variable > > _commandVariables;

        /// @brief Map containing the OFF timers for the components.
        std::map< std::string, std::shared_ptr< chase::Variable > > _offTimer;

        /// @brief Map containing the ON timers for the components.
        std::map< std::string, std::shared_ptr< chase::Variable > > _onTimer;

        /// @brief Set of components which state does not vary.
        std::set< std::string > _nonVariableComponents;

        /// @brief Set of components that cannot be controlled.
        std::set< std::string > _nonControllableComponents;

        /// @brief The time precision required by the system.
        chase::chase_time * _precision;

        /// @brief Pointer to the architecture of the system.
        std::shared_ptr< chase::Graph > _architecture;

        /// @brief Function generating the contract from a populated
        /// DesignProblem object.
        /// @return The generated contract.
        chase::Contract * _generateContract();

        /// @brief Function that retrieves the components given a string.
        /// @param s The string to be used for the search.
        /// @return set of all the components (names) compliant with the pattern.
        std::set< std::string > _findComponents( std::string s );

        /// @brief Procedure creating the graph representing the assumed
        /// architecture. The graph is stored in the assumptions of the
        /// contract.
        void _createArchitecture();

        /// @brief Procedure retrieving timing precision.
        void _retrieveTimingPrecision();

        /// @brief Prune the variables by analyzing the assumptions to
        /// identify which components are assumed to have a
        /// variable state, or which can be controlled, etc.
        /// It analyzes the no-control and the never-fail patterns.
        void _pruneComponentsVariables();

        /// @brief Method analyzing the assumptions. All the assumptions but
        /// the no-control and never-fail patterns.
        void _analyzeAssumptions();

        /// @brief Method analyzing the requirements.
        void _analyzeRequirements();

        /// @brief Procedure searching for all the components which state does
        /// not vary.
        void _findNonVariableComponents();

        /// @brief Procedure finding the components that cannot be controlled.
        void _findNonControllableComponents();

        /// @brief Procedure creating the variables of the components.
        void _generateComponentsVariables();

        /// @brief Procedure introducing the mechanism command -> X state for
        /// all the components that does not specify a explicit delay.
        void _completeCommandState();

        /// @brief Function computing the precision.
        /// @param A vector of timings.
        /// @return The GCD of the timings. I.e., the precision of the system.
        static chase::chase_time *
        _compute_precision(std::vector<chase::chase_time *> *pVector);

        /// @brief Given a timing, it returns the steps represented based on the
        /// precision that has been set for the problem.
        /// @param timing the timing to be analyzed.
        /// @return the number of steps necessary to reproduce the given timing.
        unsigned int _compute_steps(chase::chase_time & timing);

        // ----- Functions managing the patterns.
        /// \todo Deep documentation of the functions.

        std::set< std::shared_ptr< chase::LogicFormula > > _gr1_env_init;
        std::set< std::shared_ptr< chase::LogicFormula > > _gr1_env_safety;
        std::set< std::shared_ptr< chase::LogicFormula > > _gr1_env_liveness;

        std::set< std::shared_ptr< chase::LogicFormula > > _gr1_sys_init;
        std::set< std::shared_ptr< chase::LogicFormula > > _gr1_sys_safety;
        std::set< std::shared_ptr< chase::LogicFormula > > _gr1_sys_liveness;

        // ----- Functions managing the patterns: Assumptions
        // ----- Implemented in DesignProblem_patterns.cc

        /// @brief
        /// @param spec The specification function to be analyzed.
        void _noRecovery(SpecFunction * spec);

        /// @brief
        /// @param spec The specification function to be analyzed.
        void _maxFailures(SpecFunction *spec);

        /// @brief
        /// @param spec The specification function to be analyzed.
        void _initialState(SpecFunction *spec);

        /// @brief
        /// @param spec The specification function to be analyzed.
        /// @param onoff True for the ON time pattern, False otherwise
        void _switchTime(SpecFunction *spec, bool onoff);

        // ----- Functions managing the patterns: Guarantees
        // ----- Implemented in DesignProblem_patterns.cc
        /// @brief
        /// @param spec The specification function to be analyzed.
        /// @param onoff True for the ON time pattern, False otherwise
        void _neverConnect(SpecFunction *spec);

        /// @brief
        /// @param spec The specification function to be analyzed.
        /// @param onoff True for the ON time pattern, False otherwise
        void _mustDisconnectFailed(SpecFunction *spec);

        /// @brief
        /// @param spec The specification function to be analyzed.
        /// @param onoff True for the ON time pattern, False otherwise
        void _preferActiveConnection(SpecFunction *spec);

        /// @brief
        /// @param spec The specification function to be analyzed.
        /// @param onoff True for the ON time pattern, False otherwise
        void _neverDisconnect(SpecFunction *spec);

        /// @brief
        /// @param spec The specification function to be analyzed.
        /// @param onoff True for the ON time pattern, False otherwise
        void _keepConnectionStable(SpecFunction *spec);


        // -------------- Support functions ----------------------------------
        // ---- Implemented in DesignProblem_support.cc ----------------------

        std::shared_ptr< chase::LogicFormula >
            _activatePath( std::vector< unsigned >& path );
        std::shared_ptr< chase::LogicFormula >
            _pathDoesExist( std::vector< unsigned >& path );

    };

}
